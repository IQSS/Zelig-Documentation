\documentclass{article}

\title{Rapid Zelig Development: A Guide to Adding Existing Models into Zelig}
\author{Matt Owen}

\newcommand{\code}[1]{{\tt #1}}


\begin{document}

\maketitle


\section{Introduction}

Programming a Zelig module is a fairly simple procedure. While the details of modeling an arbitrary statistical model may often be esoteric, a procedure exists for transforming existing statistical models into Zelig-compliant software. The following document places emphasis on speed and practicality, rather than the numerous, technical details involved in developing statistical models. That is, this guide will explain how to quickly and most simply develop Zelig packages.

\section{\code{zelig.skeleton}: Automating Zelig Model Creation}

The fastest way to setup and begin programming a Zelig model is the use the \code{zelig.skeleton} method, available within the \code{Zelig} package. This method allows a fast, simple way to create \code{zelig2}, \code{describe}, \code{param}, and \code{qi} methods with the necessary boilerplate. As a result, \code{zelig.skeleton} closely mirrors the \code{package.skeleton} method included in core R.

\subsection{A Demonstrative Example}

\begin{verbatim}
library(Zelig)  # [1]

zelig.skeleton(
               "my.zelig.package",                # [2]
               models = c("gamma2", "newLogit"),  # [3]
               author = "Your Name",              # [4]
               email = "your.email@someplace.com" # [5]
               )
\end{verbatim}

\subsection{Explanation of the \code{zelig.skeleton} Example}

The above numbered comments correspond to the following:

\begin{enumerate}
	\item The Zelig package must be imported when using \code{zelig.skeleton}.
	\item The first parameter of \code{zelig.skeleton} specifies the name of the package
	\item The \code{models} parameter specifies the titles of the Zelig models to be included in the package. In the above example, "gamma2" and "newLogit" will be included in Zelig package, along with the necessary \code{zelig2}, \code{describe}, \code{param}, and \code{qi} methods.
	\item Specify the author's name
	\item Specify the email address of the software maintainer
\end{enumerate}

\subsection{Conclusion}

The \code{zelig.skeleton} method provides a way to automatically generate the necessary methods for an arbitrary Zelig package. The method body, however, will be incomplete, save for some light documentation additions and programming boilerplate. For a detailed specification of the \code{zelig.skeleton} method, refer to Zelig help file by typing:

\begin{verbatim}
library(Zelig)

?zelig.skeleton
\end{verbatim}

{\noindent}in an interactive R-session.
 

\section{\emph{zelig2}: Interacting with Existing Statistical Models in Zelig}
\label{section:zelig2}

The \code{zelig2} function acts as the bridge between the Zelig module and
the existing statistical model. That is, the results of this function specify
the parameters to be passed to a previously completed statistical model-fitting
function. In this sense, there is nothing tricky about the \code{zelig2} function.
Simply construct a list with key-value pairs in the following fashion:

\begin{itemize}

  \item {\bf Keys} (names on the lefthand-side of an equal sign) represent
        parameters that are submitted to the existing model function
        
  \item {\bf Keys with leading periods} are typically reserved for specific
        \code{zelig2} purposes. In particular, the key \code{.function}
        specifies the name of the function that calls the existing statistical
        model.
  
  \item {\bf Values} (variables, etc. on the righthand-side of an equal sign)
        represent values to set the corresponding the parameter to.

\end{itemize}

\subsection{A Simple Example}

\noindent For example, if a developer wanted to call an existing model
\code{"SomeModel"} with the parameter \code{weights} set to \code{1},
the appropriate return-value (a list) for the \code{zelig2} function would be:


% SHORT EXAMPLE
\begin{verbatim}
    list(.function = "SomeModel",
         weights   = 1
         )
\end{verbatim}


% ....
\subsection{A More Detailed Example}

\noindent A more typical example would be the case of fitting a basic logistic
regression. The following code, already implemented in Zelig, acts as an
interface between Zelig and R's built-in \code{glm} function:


% LONG EXAMPLE
\begin{verbatim}
zelig2logit <- function (formula, weights = NULL, ..., data) {
  list(.function = "glm",    # [1]
       
       formula = formula,    # [2]
       weights = weights,    # ...
       data    = data,       # ...

       family  =             # [3]
                 binomial(link="logit"),
       model   = FALSE       # ...
       )
}
\end{verbatim}

\noindent The comments in the above code correspond to the following:

\begin{description}
	\item[ \#1 ] Pass all parameters to the \code{glm} function

	\item[ \#2 ] Specify that the parameters \code{formula}, \code{weights},
	and \code{data} be given the same values as those passed into the
	\code{zelig2} function itself. That is, whichever values the end-user
	passes to \code{zelig} will be passed to the \code{glm} function

	\item[ \#3 ] Specify that the parameters \code{family} and \code{model}
	\emph{always} be given the corresponding values -
	\code{binomial(link="logit")} and \code{FALSE} - regardless of what
	the end-user passes as a parameter
	
\end{description}


\subsection{Summary and More Information}

\code{zelig2} functions can be of varying difficulty - from simple parameter
passing to doing important computations concerning survey weighted models
(see the package \code{survey.zelig} for code examples). Regardless of the model's
complexity, it ends with a simple list specifying which parameters to pass to
a preexisting statistical model.

For more information on the \code{zelig2} function's full features, see
the \emph{Advanced zelig2 Manual}, or type \code{?zelig2} within an interactive R-session.


% Section: param
\pagebreak
\section{\emph{param}: Simulating Parameters}
\label{section:param}


The \code{param} function simulates and specifies parameters necessary for computing
\emph{quantities of interest}. That is, the \code{param} function is the ideal place
to specify information necessary for the \code{qi} function. This includes:

\begin{description}

	\item[Auxiliary parameters] That is, parameters specifying information about the
		underlying probability distribution. For example, in the case of the Normal
		Distribution, $\sigma$ and $\mu$ would be considered auxiliary parameters
	
	\item[Link function] That is, the function providing the relationship between
		the predictors and the mean of the distribution function. This is typically of
		very little importance, but is included for completeness. For the Normal
	
	\item[Inverse link function] Typically crucial for simulating \emph{quantities of
		interest} of \emph{Generalized Linear Models}. For the Normal Distribution, this
		would be the logit function
	
	\item[Simulations] Random draws taken to approximate the log-likelihood of
	\emph{quantities of interest}

\end{description}

The following describes how these ideas correspond to the structure of a well-written
\code{param} function.

\subsection{The Function Signature}

The \code{param} function takes very few parameters, but outputs a wealth of information
important in computing \emph{quantities of interest}.

\begin{verbatim}
  param.logit <- function (obj, num)
\end{verbatim}

\noindent The above parameters are:

\begin{description}

	\item[obj] An object of class \code{zelig}. This contains the fitted statistical model,
		and a wealth of information concerning the underlying probability distribution
	
	\item[num] An integer specifying the number of simulations to be drawn. This value is
		specified by the end-user, and defaults to \code{1000}

\end{description}



\subsection{The Function Return Value}

In similar fashion to the \code{zelig2} function, the \code{param} function takes return
values as a list of key-value pairs. However, the options are not as diverse. That is, 
the list can only be given a set of specific values: \code{ancillary}, \code{coef},
\code{simulations}, \code{link}, \code{linkinv}, etc.

In most cases, however, the parameters \code{ancillary}, \code{simulations}, and
\code{linkinv} are sufficient. The following is an example take from Zelig's \code{gamma}
model:

\begin{verbatim}
param.gamma <- function(obj, num) {

  # simulate ancillary parameter
  alpha <- rnorm(n=num, mean=shape$alpha, sd=shape$SE)
  
  # simulate log-likelihood
  sims <- mvrnorm(n = num, mu = coef(obj), Sigma = vcov(obj))

	# return results  
  list(
       alpha = alpha,       # [1]
       simulations  = sims, # [2]
                            # ...
                               
                            # [3]
       linkinv = function (x) 1/x
       )
}

\end{verbatim}

The above code does the following:

\begin{enumerate}

	\item Specify the ancillary parameter, typically referred to as the greek letter $\alpha$.
		In the above example, \code{alpha} is a simulation of the model's shape parameters
	
	\item Specify the simulations to be used in the \code{qi} function. 
	
	\item Specify the inverse-link function

\end{enumerate}


\subsection{Summary and Conclusion}

The \code{param} method's basic purpose is to describe the statistical and systematic variables of the Zelig model's underlying distribution. Defining this method is an important step towards simplifying the \code{sim} method. That is, by specifying features of the model - coefficients, systematic components, inverse link functions, etc. - and simulating specific parameters, the \code{sim} method can focus entirely on simulating \emph{quantities of interest}, rather than
	




\section{qi: Simulating Quantities of Interest}

The \code{qi} function of a Zelig model simulates \emph{quantities of interest}
using the fitted statistical model, taken from the \code{zelig2} function,
and the simulated parameters, taken from the \code{param} function. As a result,
the \code{qi} function is the most important component of a Zelig model.

\subsection{The \code{qi} Function Signature}

While the implementation of the \code{qi} function can differ greatly from one
model to another, the signature always remains the same and closely parallels the 
signature of the \code{sim} function.


\begin{verbatim}
qi.logit <- function(obj, x=NULL, x1=NULL, y=NULL, param=NULL)
\end{verbatim}



\subsection{The \code{qi} Function Return Values}

Similar to the return values of both the \code{zelig2} and \code{param} function,
the \code{qi} function takes an list of key-value pairs as a return value. The keys,
however, follow a much simpler convention, and a single rule: the key (left-side
of the equal sign) is a \emph{quoted} character-string naming the \emph{quantity of
interest} and the value (right-side of the equal sign) are the actual simulations.

The following is a short example:

\begin{verbatim}
  list(
       "Expected Value"  = ev,
       "Predicted Value" = pv
       )
\end{verbatim}

\noindent where \code{ev} and \code{pv} are respectively simulations of the model's
\emph{expected values} and \emph{predicted values}.

\subsection{Coding Conventions for the \code{qi} Function}

While the following is unnecessary, it provides a few simple guidelines to simplifying
and improving readability of a model's \code{qi} function:

\begin{itemize}

	\item Divide repetitive work amongst other functions. For example, if you simulate
		an \emph{expected value} for both the \code{x} and \code{x1}, it is better to 
		write a \code{.compute.ev} function and simply call it twice
		
	\item Always compute an \emph{expected values} and \emph{predicted values} independently
		and before writing code to create \emph{first differences}, \emph{risk ratios}, and
		\emph{average treatment effects}
		
	\item Write code for \emph{average treatment effects} only after all the other code has
		been debugged and completed

\end{itemize}

\pagebreak
\subsection{A Simplified Example}

The following is a simplified example of the \code{qi} function for the logit model:


\subsubsection{\code{qi.logit} Function}
\begin{verbatim}
#' simulate quantities of interest for the logit models
qi.logit <- function(z, x=NULL, x1=NULL, y=NULL, num=1000,
param=NULL) {

  # [1]
  ev1 <- .compute.ev(obj, x, num, param)
  ev2 <- .compute.ev(obj, x1, num, param)

  # [2]
  list(
       "Expected Values: E(Y|X)"  = ev1,
       "Expected Values (for X1)" = ev2,
       
  # [3]
  # ...
       "First Differences: E(Y|X1) - E(Y|X)" = ev2 - ev1
       )
}
\end{verbatim}


\subsubsection{\code{.compute.ev} Function}
\begin{verbatim}
.compute.ev <- function(obj, x=NULL, num=1000, param=NULL) {

	# values of NA are ignored by the summary function
  if (is.null(x))
    return(NA)

	# extract simulations
  coef <- coef(param)
  
  link.inverse <- linkinv(param)

  # 
  eta <- coef %*% t(x)

  # invert link function
  theta <- matrix(link.inverse(eta), nrow = nrow(coef))
  ev <- matrix(theta, ncol=ncol(theta))

  ev
}  
\end{verbatim}

\noindent The above code illustrates a few of the ideas:

\begin{enumerate}

	\item Compute \emph{expected values} using the \code{.compute.ev} function
		that is defined at the bottom of the example
	
	\item Return \emph{quantities of interest} as a list. Note: titles of
		\emph{quantities of interest} are on the left of the equal signs, while
		simulated values are on the right
		
	\item Simulate \emph{first differences} by using two previous computed
	  \emph{quantities of interest}
	  
	\item Define the function that simulates \emph{expected values}

\end{enumerate}

\noindent In addition, this function two \emph{generic functions} that are
defined in the Zelig software suite:

\begin{description}

	\item[coef] Extract the simulations of the parameters. In particular, this
		returns the simulations produced in the \code{param} function
	
	\item[linkinv] Return the inverse of the link function. In particular, this
		returns the inverse-link functions specified in the \code{param} function

\end{description}

\subsection{Summary and Conclusion}

The \code{qi} function offers a simple template for computing \emph{quantities of
interest}. Particularly, if a few a coding conventions are followed, the \code{qi}
function can provide transparent, easy-to-read simulation methods.


















\end{document}